// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

import (
	"fmt"
	"net/http"
	"time"

	"github.com/Masterminds/squirrel"
	"github.com/jmoiron/sqlx"
	"github.com/oleglarionov/otusgolang_hw/hw12_13_14_15_calendar/api"
	"github.com/oleglarionov/otusgolang_hw/hw12_13_14_15_calendar/internal/common"
	"github.com/oleglarionov/otusgolang_hw/hw12_13_14_15_calendar/internal/domain/event"
	"github.com/oleglarionov/otusgolang_hw/hw12_13_14_15_calendar/internal/infrstructure/logger/logrus"
	"github.com/oleglarionov/otusgolang_hw/hw12_13_14_15_calendar/internal/infrstructure/repository/memory"
	"github.com/oleglarionov/otusgolang_hw/hw12_13_14_15_calendar/internal/infrstructure/repository/sql"
	"github.com/oleglarionov/otusgolang_hw/hw12_13_14_15_calendar/internal/infrstructure/uuid"
	"github.com/oleglarionov/otusgolang_hw/hw12_13_14_15_calendar/internal/server/grpc"
	handler2 "github.com/oleglarionov/otusgolang_hw/hw12_13_14_15_calendar/internal/server/grpc/handler"
	"github.com/oleglarionov/otusgolang_hw/hw12_13_14_15_calendar/internal/server/grpc/middleware"
	"github.com/oleglarionov/otusgolang_hw/hw12_13_14_15_calendar/internal/server/http"
	"github.com/oleglarionov/otusgolang_hw/hw12_13_14_15_calendar/internal/server/http/handler"
	"github.com/oleglarionov/otusgolang_hw/hw12_13_14_15_calendar/internal/usecase"
)

// Injectors from wire.go:

func setup(cfg Config) (*CalendarApp, error) {
	logger, err := loggerProvider(cfg)
	if err != nil {
		return nil, err
	}
	eventParticipantRepository := memory.NewEventParticipantRepository()
	db, err := dbProvider(cfg)
	if err != nil {
		return nil, err
	}
	statementBuilderType := sql.NewStatementBuilder()
	repository, err := eventRepositoryProvider(cfg, eventParticipantRepository, db, statementBuilderType)
	if err != nil {
		return nil, err
	}
	participantRepository := sql.NewEventParticipantRepository(db, statementBuilderType)
	service := event.NewService(repository, participantRepository)
	uuidGenerator := uuid.NewGenerator()
	location, err := locationProvider()
	if err != nil {
		return nil, err
	}
	eventUseCaseImpl := usecase.NewEventUseCaseImpl(repository, participantRepository, service, uuidGenerator, location)
	handlerHandler := handler.NewHandler(eventUseCaseImpl, logger)
	httpHandler := httpHandlerProvider(handlerHandler)
	server := httpServerProvider(cfg, httpHandler, logger)
	eventServiceServerImpl := handler2.NewEventServiceServerImpl(eventUseCaseImpl)
	loggingMiddleware := middleware.NewLoggingMiddleware(logger)
	authenticationMiddleware := middleware.NewAuthenticationMiddleware()
	v := grpcMiddlewaresProvider(loggingMiddleware, authenticationMiddleware)
	internalgrpcServer, err := grpcServerProvider(cfg, eventServiceServerImpl, v)
	if err != nil {
		return nil, err
	}
	calendarApp := NewApp(logger, server, internalgrpcServer, db)
	return calendarApp, nil
}

// wire.go:

func loggerProvider(cfg Config) (common.Logger, error) {
	return logrusadapter.New(logrusadapter.Config(cfg.Logger))
}

func httpServerProvider(cfg Config, handler3 http.Handler, l common.Logger) *internalhttp.Server {
	return internalhttp.NewServer(internalhttp.Config(cfg.HTTPServer), handler3, l)
}

func httpHandlerProvider(h *handler.Handler) http.Handler {
	return h.InitRoutes()
}

func grpcServerProvider(cfg Config, eventService api.EventServiceServer, middlewares []middleware.Middleware) (*internalgrpc.Server, error) {
	return internalgrpc.NewServer(cfg.GrpcServer.Port, eventService, middlewares)
}

func grpcMiddlewaresProvider(
	loggingMiddleware *middleware.LoggingMiddleware,
	authenticationMiddleware *middleware.AuthenticationMiddleware,
) []middleware.Middleware {
	return []middleware.Middleware{
		loggingMiddleware,
		authenticationMiddleware,
	}
}

func eventRepositoryProvider(
	cfg Config,
	participantRepository *memory.EventParticipantRepository,
	db *sqlx.DB,
	sbt squirrel.StatementBuilderType,
) (event.Repository, error) {
	repoType := cfg.Repository.Type
	switch repoType {
	case "memory":
		return memory.NewEventRepository(participantRepository), nil
	case "sql":
		return sql.NewEventRepository(db, sbt), nil
	default:
		return nil, fmt.Errorf("unsupported participantRepository type: %s", repoType)
	}
}

func dbProvider(cfg Config) (*sqlx.DB, error) {
	if cfg.Repository.Type != "sql" {
		return nil, nil
	}

	return sql.NewDB(cfg.DB.DSN)
}

func locationProvider() (*time.Location, error) {
	return time.LoadLocation("Europe/Moscow")
}
